<!-- omit from toc -->
# Какие-то узлы и топики 


## Содержание
- [Содержание](#содержание)
- [ROS узлы и топики](#ros-узлы-и-топики)
  - [Основные инструменты](#основные-инструменты)
    - [rosnode](#rosnode)
    - [rostopic](#rostopic)
    - [rosmsg](#rosmsg)
  - [Добавим графику](#добавим-графику)
- [Создание ROS Publisher с использованием rospy](#создание-ros-publisher-с-использованием-rospy)
- [Создание ROS Subscriber с использованием rospy](#создание-ros-subscriber-с-использованием-rospy)
- [ROS имена и пространства имен ну и еще мапирование](#ros-имена-и-пространства-имен-ну-и-еще-мапирование)
  - [Node name](#node-name)
  - [Node namespace](#node-namespace)
  - [Node remapping](#node-remapping)
- [С чем познакомились?](#с-чем-познакомились)
- [Полезные ресурсы](#полезные-ресурсы)

## ROS узлы и топики

Вот и настало время познакомиться с основами ROS — **узлами**. Узел представляет собой программу, выполняющую определённые действия. Узлы соединяются посредством **топиков**, через которые они обмениваются **сообщениями**.

Чтобы лучше понять концепцию узлов, представьте себе узел камеры как фотографа, начинающего работу в офисе журнала. В свой первый рабочий день он делает несколько снимков и сообщает своему боссу, что оставит фотографии на определённом столе в офисе. Босс благодарит его за информацию.

В нашей истории Босс олицетворяет **Мастера ROS**, который всегда должен находиться в системе при использовании ROS. Мастер ROS предоставляет услуги по именованию и регистрации для остальных узлов, отслеживая публикаторов и подписчиков топиков. Чтобы запустить Мастера ROS, необходимо выполнить команду `roscore`. Важно помнить, что **одновременно может работать только один Мастер ROS**. Если вы попытаетесь запустить ещё одного, возникнет ошибка. Фотограф, в свою очередь, представляет собой **Узел ROS**, который всегда должен регистрироваться у **Мастера** при запуске, подобно тому, как фотограф уведомляет своего босса.

<p align="center">
    <img src="../assets/ros/ros_master.avif" width=500>
</p>


Начнем, чтобы запустить **узел**, нужно воспользоваться утилитой запуска узла `rosrun`, которая имеет следующее описание:

`rosrun [pkg_name] [node_name] [additional args]`  

- **pkg_name** - имя пакета, в котором узел содержится  
- **node_name** - имя узла в пакете  
- **additional args** - дополнительные аргументы (рассматривается позже, в нашем случае используется явное задание имени узла в экосистеме ROS (`__name`) )

Let's Go! Cоздаем простейшую систему с топиком и узлами:

- запуск ROS мастера, вся систем зиждется на нем и без него ничего не работает:

```bash
roscore
```
- узел из пакета `rospy_tutorials` с именем `talker` командой:
  
```bash
rosrun rospy_tutorials talker
```
- узел из пакета `rospy_tutorials` с именем `listener` командой:
  
```bash
rosrun rospy_tutorials listener
```

**Запустите узлы утилиты. Не забывайте про то, что если узел при запуске работает бесконечно, то для запуска другого узла нужен новый терминал.**

### Основные инструменты

#### rosnode

Открываем еще один терминал и начинаем анализ системы вместе с испытанием инструментов.

> Проверьте возможные команды утилиты `rosnode`

Посмотрим список узлов в системе с помощью:

```bash
rosnode list
```

Также можно посмотреть информацию о конкретном узле, например `/talker`:

```bash
rosnode info /talker
```
Команда нам выдаст следующее

```
Node [/talker]
Publications: 
 * /chatter [std_msgs/String]
 * /rosout [rosgraph_msgs/Log]

Subscriptions: None

Services: 
 * /talker/get_loggers
 * /talker/set_logger_level


contacting node http://user-vb:39115/ ...
Pid: 8733
Connections:
 * topic: /chatter
    * to: /listener
    * direction: outbound
    * transport: TCPROS
 * topic: /rosout
    * to: /rosout
    * direction: outbound
    * transport: TCPROS
```

Сделаем небольшой анализ увиденного:
- Узел зовется `/talker`
- Публикует в два топика: `/chatter` и `/rosout`, второй - топик для логирования, в него автоматически публикуют все узлы, более конкретно рассмотрим потом
- Подписок нет
- Имеет два сервиса, которые тоже создаются автоматически у каждого узла, о сервисах потом
- PID (Porcess ID) = 8733 - это идентификатор процесса в системе Linux, нам он не важен
- Имеет соединения, они должны сходиться с названиями подписок и публикаций, таким образом сообщается, что все публикуется и подписывается корректно (соединения между узлами настроены)

> Попробуйте проанализировать информацию об узле `/listener`

#### rostopic

Теперь взглянем на возможности утилиты для анализа топиков

> Проверьте возможные команды утилиты `rostopic`

Посмотрим на список топиков в системе
```bash
rostopic list
```

Для вывода в более подробной форме воспользуемся опцией -v

```bash
rostopic list -v
```

```
Published topics:
 * /chatter [std_msgs/String] 1 publisher
 * /rosout [rosgraph_msgs/Log] 2 publishers
 * /rosout_agg [rosgraph_msgs/Log] 1 publisher

Subscribed topics:
 * /chatter [std_msgs/String] 1 subscriber
 * /rosout [rosgraph_msgs/Log] 1 subscriber
 ```

В выводе видна информация о подписках и публикациях топиков.

Взглянем на информацию о конкретном топике

```bash
rostopic info /chatter
```

```
Type: std_msgs/String

Publishers: 
 * /talker (http://user-vb:39115/)

Subscribers: 
 * /listener (http://user-vb:42123/)
```

По выводу можно определить, какие узлы подписаны на топик, а какие публикуют в него сообщения.

Далее можно показать сообщения, которые идут через этот топик. Для завершения нажмите Ctrl+C.

```bash
rostopic echo /chatter
```

```
data: "hello world 1536699023.89"
---
data: "hello world 1536699023.99"
---
...
```

> Найдите в справке утилиты `rostopic` аргумент измерения частоты публикации и измерьте частоту публикации в топик `/chatter`

#### rosmsg

Также существует утилита `rosmsg`, которая анализирует типы сообщений

> Проверьте возможные команды утилиты `rosmsg`

В информации о топике мы видели поле типа сообщений, которые идут через этот топик

```
Type: std_msgs/String
```

В типе можно видеть имя пакета типа `std_msgs` и само название `String`. Чтобы просмотреть, что содержит данный тип сообщения, воспользуемся командой

```bash
rosmsg show std_msgs/String
```

Результат:

```
string data
```

Как видно, данный тип сообщения содержит строковое поле `data`. Таким образом утилита анализирует информацию, связанную со строением (прототипом) сообщения, а не c самими данными в них.

А теперь посмотрим, какие есть сообщения в системе ROS

```bash
rosmsg list
```

Так как их много, вывод не приводится

Самый основной пакет сообщений - `std_msgs`, его типы можно глянуть командой, которая показывает типы сообщений, определенные в данном пакете

> Пройдите все представленные шаги, просмотрите типы сообщений `std_msgs/ColorRGBA`, `geometry_msgs/Pose2D`

### Добавим графику

Запустите графическое представление графа экосистемы с помощью утилиты `rqt_graph`. Вы увидите графический интерфейс, на котором отображены узлы и топик в нашей системе. Также можно управлять настройкой группы `Hide`, что позволяет скрывать некоторые элементы в соответствии с настройкой.

> Включите `rqt_graph` и в группе `Hide` снимите галочку с `Debug`. Убедитесь в том, что представлены все узлы и топики (даже с отладкой) системы, с помощью утилит `rosnode` и `rostopic`. Как видно, узел `/rosout` и топик `/rosout` создаются для отладки и соединяются со всеми узлами через топик `/rosout`.

> Запустите узел пакета `rospy_tutorials` с именем `listener`, но присвойте имя `__name:=listener2`. Проверьте с помощью `rqt_graph`, что оба `listener` подключилиь на общий топик.

> Запустите два узла из пакета `rospy_tutorials` с именем `talker` и присвойте им одинаковые имена `__name:=talker`. Убедитесь, что первый `talker` закрылся с сообщением о перехвате (`shutdown request: new node registered with same name`).

## Создание ROS Publisher с использованием rospy

Самое время познакомиться с возможностями написания узлов на языке Python.

Чтобы создать узел фотографа, который будет отправлять приветственные сообщения каждую секунду, мы можем использовать тип сообщения **String** из стандартного пакета ROS. Давайте напишем код для узла фотографа на Python, который будет публиковать сообщения с помощью **ROS Publisher**.

```python
#!/usr/bin/env python3
import rospy
from std_msgs.msg import String

rospy.init_node('talker')
pub = rospy.Publisher('my_chat_topic', String, queue_size=10)
rate = rospy.Rate(1)

def start_talker():
    msg = String()
    while not rospy.is_shutdown():
        hello_str = "hi =) %s" % rospy.get_time()
        rospy.loginfo(hello_str)

        msg.data = hello_str
        pub.publish(msg)

        rate.sleep()

try:
    start_talker()
except (rospy.ROSInterruptException, KeyboardInterrupt):
    rospy.logerr('Exception catched')
```

А теперь пошел разбор. Для начала, импортируем основной модуль `rospy` и модуль сообщения типа `std_msgs/String`. 

```python
#!/usr/bin/env python3
import rospy
# Our case:     std_msgs/String     -> from std_msgs.msg import String
# Example:      geometry_msgs/Pose  -> from geometry_msgs.msg import Pose
from std_msgs.msg import String
``` 

После этого необходимо зарегистрировать узел в системе ROS, а также зарегистрировать топик на публикацию с указанием имени, типа сообщения для топика и размера очереди.

Первый аргумент функции `init_node()` задает название, которое будет зарегистрировано в рабочей экосистеме ROS.

Очередь нужна для сохранения сообщений, если узел публикует сообщения часто, при этом низкоуровневая передача сообщений работает медленнее или с задержками. При переполнении очереди отправляются наиболее актуальные данные.

```python
rospy.init_node('talker')
pub = rospy.Publisher('my_chat_topic', String, queue_size=10)
```

При регистрации узла функцией `init_node()` у конструктора есть флаг `anonymous` со значение по-умолчанию `False`. Так при включении этого флага

```python
rospy.init_node('talker', anonymous=True)
```

к указанному имени узла добавляется суффикс (получается, например, `talker_18231_12354`), который делает узел уникальным в системе (свойство **анонимности**).

У функции `rospy.Publisher()` есть флаг `latch` со значение по-умолчанию `False`. Его включение добавляет следующее поведение: при отправке сообщений в топик сохраняется последнее отправленное сообщение и когда кто-нибудь подписался на этот топик - он сразу получает последнее сообщение из этого топика, даже если отправка была раньше, чем узел подписался на топик. Помогает, если в топик один раз опубликовались данные, а другой узел подписался на этот топик намного позже.

После остается только создать объект `Rate`, который используется для выдерживания частоты выполнения кода. В конструктор передается значение частоты в Гц.

```python
rate = rospy.Rate(1) # 1 Hz
```

На этом подготовка и создание необходимых объектов для простейшего узла готовы и пора перейти к основной логике программы.

В API ROS есть функция, которая сообщает о том, что система ROS завершила работу, именно ей и воспользуемся в качестве условия выхода `rospy.is_shutdown()`. Далее определим функцию с основной логикой узла для дальнейшего запуска.

```python
def start_talker():
    # Создаем объект сообщения
    msg = String()
    # Бесконечный цикл, пока ROS система работает
    while not rospy.is_shutdown():
        # Сформируем сообщение, которое включает в себя время
        hello_str = "hi =) %s" % rospy.get_time()
        # Вывод в терминал информации (содержание сообщения)
        rospy.loginfo(hello_str)
        # Заполнение сообщения и публикация сообщения в топик
        msg.data = hello_str
        pub.publish(msg)
        # Сон в соответствии с выдерживаемой частотой
        rate.sleep()
```

После этого можем запустить функцию узла (в ней находится вся логика). При этом заворачиваем в конструкцию `try-catch`, чтобы обработать исключение (нажатием Стоп или Ctrl+C в терминале).

```python
try:
    start_talker()
except (rospy.ROSInterruptException, KeyboardInterrupt):
    rospy.logerr('Exception catched')
```

> Задачка по самостоятельной интеграции скрипта в наш пакет:
- Внутри пакета создать папку `scripts` (Python файлы считаются скриптами), в ней создать файл talker.py и в нем разместить код узла.
- Далее дать права на выполение с помощью команды `chmod +x talker.py`. Необходимо, чтобы вы находились в одной папке со скриптом.
- Попробовать запустить в системе ROS созданный узел, для ранее созданного пакета команда будет следующей:
`rosrun study_pkg talker.py`
- Поскольку мы не задавали флаг анонимности в функции `rospy.init_node('talker')` (по-умолчанию там стоит `anonymous=False`), явно присваивать имя узла не требуется, оно будет такое, как было задано в функции `rospy.init_node()`
- При возникновении каких-либо ошибок, они будут выведены в терминале 

## Создание ROS Subscriber с использованием rospy

**ROS Subscriber** — это узел, который подписывается на определённые **топики** и получает **сообщения**, отправляемые другими узлами, такими как публикаторы. Чтобы лучше понять, как работает подписка в ROS, давайте продолжим нашу историю.

Представьте, что в офисе журнала появился новый персонаж — редактор, который хочет работать в команде с фотографом. Его задача заключается в том, чтобы брать у фотографа интервью и получать готовые снимки.

Первоначально редактору необходимо уведомить Босса (Мастера ROS) о том, что он собирается начать совместную работу с фотографом. Для этого редактор регистрируется у Мастера ROS, сообщая ему о своей роли и намерениях. После успешной регистрации редактор становится подписчиком.

Если фотограф готов к сотрудничеству и открывает канал общения, редактор может начать взаимодействовать с ним, запрашивая необходимые материалы и задавая вопросы. В этом случае редактор будет получать сообщения от фотографа, подписываясь на соответствующий топик, где фотограф публикует свои снимки и информацию. Таким образом, редактор и фотограф смогут эффективно сотрудничать, обмениваться данными и работать над совместными проектами.

<p align="center">
    <img src="../assets/ros/ros_subscriber.avif" width=500>
</p>

После того как редактор уведомил Босса и фотографа о своем намерении работать с ними, все участники команды начинают знать друг о друге. Теперь они могут легко обмениваться сообщениями и информацией.

Фотограф, как **публикатор**, **отправляет** свои новости о работе, а редактор, как **подписчик**, **получает** эти сообщения. Благодаря этому редактор всегда в курсе, что делает фотограф, потому что будет копировать себе данные с того самого стола. Он даже может давать обратную связь, однако для этого ему понадобится другой стол (топик), так как в один стол (топик) может класть (публиковать) данные только один сотрудник (паблишер). Кстати, брать данные с любого стола может кто угодно, подписчиков у топика может быть огромное количество

Таким образом, после установления связи между всеми тремя участниками — Боссом, фотографом и редактором — их работа становится более слаженной. Теперь они могут свободно обмениваться информацией, что способствует эффективному сотрудничеству и достижению общих целей. Каждый из них знает, что ему нужно делать, и может рассчитывать на поддержку и помощь друг друга.

<p align="center">
    <img src="../assets/ros/ros_sub.avif" width=500>
</p>

Чтобы редактор мог корректно работать с фотографом и получать от него информацию, необходимо наладить контакт через один общий источник — **топик**. Давайте создадим узел, который позволит редактору слушать сообщения, отправляемые фотографом.

```python
#!/usr/bin/env python3
import rospy
from std_msgs.msg import String

def callback(msg):
    rospy.loginfo("I heard %s", msg.data)

rospy.init_node('listener')
rospy.Subscriber('my_chat_topic', String, callback, queue_size=10)
rospy.spin()
```

Для начала, импортируем основной модуль `rospy` и модуль сообщения типа `std_msgs/String`.

```python
import rospy
from std_msgs.msg import String
```

Далее пишем обработчик приема сообщений из топика, регистрируем узел и подписываемся на топик с указанием обработчика. Обработчик вызывается каждый раз, как узел получает сообщение.

```python
def callback(msg):
    rospy.loginfo("I heard %s", msg.data)

rospy.init_node('listener')
# Не требуется сохранять объект подписки, возврат функции игнорируется
rospy.Subscriber('my_chat_topic', String, callback, queue_size=10)
```

После остается лишь оставить узел работать до завершения системы ROS или прерывания узла (Ctrl+C). В момент регистрации подписки на топик узел уже готов принимать сообщения (прием происходит в отдельном потоке).

С одной стороны можно использовать `rospy.is_shutdown()`. Такая практика рапространена, если необходимо еще что-то делать в узле помимо приема сообщений.

Для простого приема сообщений можно вызвать `rospy.spin()`, который будет удерживать программу рабочей до тех пор, пока ROS не завершится или узел не бует прерван.

```python
# В данном случае достаточно спина, по факту замена `while rospy.is_shutdown()`
rospy.spin()
```

> Создайте также и скрипт `listener.py` в пакете. Запустите оба узла и убедитесь в работоспособности (один отправляет, другой получает сообщения).

## ROS имена и пространства имен ну и еще мапирование

Данная тема определяет важные аспекты, связанные с организацией системы при работе с узлами и топиками.

### Node name

Для начала определим, что **имя узла** - это имя, которое присваивается узлу при его запуске. Для того, чтобы явно указать с каким именем запускать узел, используется аргумент `__name`, например:

```bash
rosrun rospy_tutorials listener __name:=listener
```

> Знак '`:=`' означает присваивание и будет далее часто использоваться при мапировании, установки значений.

Установка имени была сделана специально, так как по-умолчанию данный узел создается **анонимным**(это свойство устанавливается в коде узла), что добавляет к его имени `listener` случайный численный суффикс. Именно поэтому мы явно и задали его имя.

> Запустите узел `listener` из пакета `rospy_tutorials` без явного указания имени и посмотрите список активных узлов, обратите внимание на имя узла

> Запустите узел `talker` из пакета `roscpp_tutorials` без явного задания имени и убедитесь в присутствии свойства анонимности.

> Запустите мастера, один узел `talker` из пакета `rospy_tutorials` с заданием имени и два узла `listener` из пакета `rospy_tutorials` без задания имени. Проверьте `rqt_graph` и убедитесь, что оба `listener` анонимные и подписались на топик `/chatter`.

### Node namespace

**Пространство имен** - фактически, это префикс имени узла в системе. Концептуально, пространство имен объединяет несколько узлов по определенной задаче, расположению или другому признаку. Задавая пространство `new_ns` узлу `talker`, мы получаем узел в системе `/new_ns/talker` и топик `/new_ns/chatter`.

Задание пространства имен для узла производится аргументом `__ns`. Также можно задать глобальное простанство имен с помощью переменной окружения `ROS_NAMESPACE`. По-умолчанию глобальное пространство имен `/`.

> Запустите узел `talker` с указание аргумента `__ns:=my_ns`. Обратите внимание на имена (префиксы) топиков и узлов.

> (Выполнив предыдущее задание) Запустите узел `listener` без явного задания пространства имен. Убедитесь в том, что `listener` не получает сообщения (нет вывода в терминале). Разберитесь в проблеме, используя `rqt_graph`, `rostopic`, `rosnode`.

Получается, простанство имен может объединять узлы (и, как следствие, их топики).

### Node remapping

**Мапирование** - переназначение имени топика. Часто используется для соединения узлов, которые в названии топиков имеют общие имена.

Часто бывает так, что необходимо написать общий узел, в котором задаются имена топиков в общих форматах. Допустим, мы пишем узел-детектор объектов на изображении (RGB -> Found objects), он подписывается на топик `rgb_img`, по которому получает изображение. В топик `objects` он публикует обработанное изображение. Для лучшего представления:

<p align="center">
    <img src="../assets/ros/2_objects.png" width=300>
</p>

Названия топиков пишутся для наилучшего понимания работы узла и написания документации.

Далее используется драйвер камеры, который публикует в топик `image` изображение с камеры:

<p align="center">
    <img src="../assets/ros/2_image.png" width=200>
</p>

А теперь вопрос знатокам, как подключить эти два узла без переписывания кода? Ответ: мапирование топиков - запуск обработчика происходит следующим образом, вот примерчик мапирования топика `image` в `rgb_img`:

```bash
rosrun usb_cam usb_cam_node image:=rgb_img
```

> Запустите узел `talker`, смапировав топик `chatter` в `chat_topic`. Запустите узел `listener`, также смапировав топик `chatter`. Оцените результат утилитой `rqt_graph`.

> Запустите узлы `talker` и `listener`, при этом мапирование произведите только для узла `listener`. Убедитесь, что узлы не соединились через топик (не вывода в `listener`). Разберитесь в проблеме, используя `rqt_graph`, `rostopic`, `rosnode`.

Таким образом, разработчику достаточно назвать имена топиков, с которыми работает узел, в общей манере. Никакого специального названия. Далее при запуске человек может сам переименовать и соединить узлы топиками так, как ему удобно.

## С чем познакомились?

- Мы научились таким аспектам организации, как имена узлов, пространства имен и мапирование топиков.
- Все рассмотренные вещи будут активно использоваться для корректной организации экосистемы на машине или в сети.
- Такие приемы позволяют писать узлы в общем виде. Далее один и тот же узел может использоваться для разных задач, при этом как названия самих узлов в системе, так и названия топиков могут быть настроены под конкретную систему.

## Полезные ресурсы

- [Узлы](http://wiki.ros.org/Nodes) и [топики](http://wiki.ros.org/Topics).
- [Написание узлов](http://wiki.ros.org/rospy_tutorials/Tutorials/WritingPublisherSubscriber)
- [Subscribers and Publishers](http://wiki.ros.org/rospy/OverviewPublishers%20and%20Subscribers)
- [Имена](http://wiki.ros.org/Names) и [мапирование](http://wiki.ros.org/Remapping%20Arguments)